# План по оптимизации и улучшению проекта CYOA Embeddings

Этот документ содержит список задач для улучшения архитектуры, производительности и надежности проекта.

## 1. Улучшение структуры и управления данными

### 1.1. Централизация конфигурации

-   **Проблема:** Константы, такие как `DB_FILE`, `EMBEDDING_MODEL_NAME`, `OUTPUT_DIMENSION`, дублируются в нескольких скриптах (`fetch_game_text.py`, `indexer.py`, `main.py` и др.). Это усложняет их изменение и может привести к ошибкам.
-   **Решение:** Создать единый файл `config.py`, в котором будут храниться все общие параметры. Остальные скрипты должны импортировать настройки из него.

    *Пример `config.py`:*
    ```python
    # --- Paths ---
    DB_FILE = "games.db"
    INDEX_FILE = "games.index"
    MAPPING_FILE = "chunk_map.json"
    LOG_FILE = "search_debug.log"
    QUERY_LOG_FILE = "user_queries.jsonl"
    SUMMARY_PROMPT_FILE = "summary_prompt.txt"

    # --- Models ---
    EMBEDDING_MODEL_NAME = "gemini-embedding-001"
    GENERATION_MODEL_NAME = "deepseek/deepseek-v3.2-exp"

    # --- API & Services ---
    BASE_GAME_URL = "https://cyoa.cafe/game/"
    POCKETBASE_URL = "https://cyoa.cafe"

    # --- Processing ---
    OUTPUT_DIMENSION = 256
    BATCH_SIZE = 100
    API_REQUEST_DELAY = 3 # seconds
    ```

### 1.2. Создание единой точки входа (CLI)

-   **Проблема:** Процесс обработки данных разбит на несколько независимых скриптов (`sync...`, `fetch...`, `generate...`, `indexer.py`), которые нужно запускать вручную в правильном порядке.
-   **Решение:** Создать главный управляющий скрипт `manage.py` с использованием библиотеки `argparse` или `click`. Это позволит запускать все этапы обработки одной командой.

    *Пример использования:*
    ```bash
    # Запустить весь пайплайн
    python manage.py process --all

    # Запустить только синхронизацию и получение текстов
    python manage.py process --sync --fetch

    # Запустить веб-сервер
    python manage.py run-server
    ```

### 1.3. Улучшение работы с базой данных

-   **Проблема:** В `main.py` и других скриптах создаются новые подключения к БД при каждом запросе/операции.
-   **Решение:** Для FastAPI (`main.py`) использовать механизм зависимостей (dependencies) для управления сессией БД. Для утилитарных скриптов можно создать общую функцию-контекстный менеджер для работы с БД.

## 2. Оптимизация производительности

### 2.1. Параллелизация загрузки текстов

-   **Проблема:** `fetch_game_text.py` обрабатывает игры последовательно. Загрузка `project.json` — это I/O-операция, которая хорошо поддается распараллеливанию.
-   **Решение:** Использовать `concurrent.futures.ThreadPoolExecutor` для одновременной загрузки `project.json` для нескольких игр. Запуск Selenium можно оставить последовательным, чтобы не перегружать систему, или выполнять его только для тех игр, где прямой метод не сработал.

### 2.2. Оптимизация переиндексации

-   **Проблема:** `indexer.py` всегда выполняет полную переиндексацию всех игр. Это неэффективно, если изменилась только одна игра.
-   **Решение:** Модифицировать `indexer.py` для поддержки инкрементальной индексации:
    1.  Добавить аргумент `--incremental` или `--since <timestamp>`.
    2.  Выбирать из БД только те игры, где `last_indexed_at` IS NULL (новые/измененные).
    3.  Загружать существующий Faiss-индекс и карту чанков.
    4.  Удалять из индекса старые векторы, относящиеся к измененным играм (по `game_id`). Это самая сложная часть, требующая `index.remove_ids()`.
    5.  Добавлять новые векторы для этих игр.
    *Примечание: Полная переиндексация проще и надежнее, поэтому эту задачу стоит выполнять, только если производительность станет реальной проблемой.*

## 3. Улучшение надежности и логирования

### 3.1. Структурированное логирование

-   **Проблема:** Логирование в `main.py` включается/выключается через константу `DEBUG_LOGGING`. Логи в других скриптах выводятся через `print()` или `tqdm.write()`.
-   **Решение:** Внедрить стандартную библиотеку `logging` во все скрипты. Настроить разные уровни логирования (INFO, WARNING, ERROR) и выводить их в консоль и/или файл. Это позволит централизованно управлять детализацией вывода.

### 3.2. Более надежная обработка ошибок в API

-   **Проблема:** В `generate_summary.py` ошибка API возвращается как строка `"API_ERROR: ..."`. Это не очень надежный способ.
-   **Решение:** Модифицировать `generate_summary_with_openrouter` так, чтобы она вызывала исключение (raise Exception) в случае ошибки. В главном потоке `process_game` оборачивать вызов в `try...except` и возвращать, например, кортеж `(pb_id, title, None, error_message)`. Это сделает обработку ошибок более явной.

## 4. Улучшения Frontend

### 4.1. Постраничная навигация для списка всех игр

-   **Проблема:** Если в базе будут тысячи игр, страница "All Games" станет очень медленной и громоздкой, так как загружает и отображает все игры сразу.
-   **Решение:**
    1.  На бэкенде (`main.py` в эндпоинте `/games`) добавить параметры `page` и `page_size` для пагинации.
    2.  На фронтенде (`static/script.js`) реализовать "бесконечную прокрутку" (infinite scroll) или кнопки "Загрузить еще", которые будут подгружать следующую порцию игр по мере необходимости.

### 4.2. Добавление фильтрации и сортировки

-   **Проблема:** Список всех игр можно только просматривать.
-   **Решение:** Добавить на фронтенд поле для текстового поиска по названию, а также фильтры (например, "Только с описанием", "Неиндексированные") и опции сортировки (по алфавиту, по дате). Соответствующие параметры должны передаваться на бэкенд.

---
